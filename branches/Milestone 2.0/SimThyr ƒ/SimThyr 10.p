{ SimThyr									  	}{ Simulator des thyreotropen Regelkreises }{ Modell 10          					          	}{ -------------------------------------	}{ Hauptprogramm und							}{ und Hilfsroutinen								}{ J. W. Dietrich, Klinikum Innenstadt der LMU München 1994 - 2002 }{ Hauptprogramm, Benutzeroberfläche, Simulator und Mac OS - Schnittstelle J. W. D. 1994 - 2000 }{ Rezeptorgleichungen, Vorhersagewerte und Dissoziationsgleichungen J. W. D. 1997 - 99}{ Prozeduren pt1 und totzt verändert und erweitert nach Hartmut Neuber, FH Lübeck 1988 }{ Funktion getgauss nach J. Flohrer 1995 }program SimThyr;	uses		TextEdit, SANE, AppleEvents, SimThyrServices, SimThyrGUI, graph;	type		bereich_xt = array[0..300] of real;	type		par_edit_ids = (paramnull, paramok, paramcancel, alphaRE, betaRE, alphaSE, betaSE, alphaS2E, betaS2E, alphaTE, betaTE, alpha31E, beta31E, alpha32E, beta32E, GRE, DRE, GHE, DHE, LSE, GTE, DTE, GD1E, KM1E, GD2E, KM2E, SSE, DSE, K30E, K31E, K41E, K42E);		timeconst_edit_ids = (timeconstnull, timeconstok, timeconstcancel, tt0r, tt0s, tt0s2, tt0t, tt03z);	const		UFT4 = 1.28E-11; {Umrechnungsfaktor ng/dl -> mol/l (T4)}		UFT3 = 1.54E-12; {Umrechnungsfaktor pg/ml -> mol/l (T3)}		UTRH = 2.76E-12; {Umrechnungsfaktor ng/l -> mol/l (TRH; MW=362) [Jackson 1987]}	var		WRect_Text: Rect;		G3, t1, x1, x2, x3, x4, x5, x6, xe, ya, t: real;		a, b, c, d, e, xd, a1, b1, c1, d1, r1, s1, p1, q1, u, v, u1, u2, Det, y1, y2, y3: real;		dTRH, TRH, TRHi, TRHe, dTSH, TSH, TSHz, dT4, T4, FT4: real;		dT3z, T3z, T3n, T3R, dT3p, T3p, FT3, Albumin, TBG, TBPA, IBS: real;		alphaR, betaR, gH, alphaS, betaS, alphaS2, betaS2, kDH, dH, LS, SS, dS, GT, alphaT, betaT, dT: real;		GD1, GD2, GR, alpha31, beta31, alpha32, beta32, kM1, kM2, dR, D3, AC1, AC2, MI, MH: real;		Tt1, Tt2, Tt22, Tt3, Tt4, tpt11, tpt12, tpt13, tpt14, tpt15, tpt16, vpt10: real;		t121, t122, t123, t124, t125, t126: real;		k1, k2, k21, k22, k3, k30, k31, k41, k42, k5, k51, k7, TRH1, dTSH1, dTSH2, TSH1, TSH2, FT41, FT42: real;		phi, chi, omega, f, dTSH3, TSH3, FT43: real;		k6, k11, k8, k9, k61, T3z1, T3z2, T3z3, T3n1, T3n2, T3n3, FT31, FT32, FT33: real;		TSHz1, TSHz2, TSHz3, T3R1, T3R2, T3R3: real;		xt1, xt2, xt22, xt3, xt4: bereich_xt;		i, nt1, nt2, nt22, nt3, nt4: integer;		i2, rastergap_text, rastergap_werte: integer;		tmax_text, tmax_unit, i1_text, i1_unit: str255;{-----------------> Regelkreisblöcke <--}	procedure pt1 (var vpt, tpt, x0, xe, ya: real);		{Verzögerungsglied erster Ordnung, nach Neuber}		var			f: real;	begin		f := exp(-delt / tpt);		ya := f * x0 + vpt * (1 - f) * xe;		x0 := ya;	end;	function totzt (var xt: bereich_xt; nt: integer; xe: real): real;		{Totzeitglied, nach Neuber, verbessert}		var			i: integer;	begin		totzt := xt[nt];		if nt > 1 then			begin				for i := nt downto 1 do					begin						xt[i] := xt[i - 1]					end;			end;		xt[1] := xe;		xt[0] := xe;	end;{-----------------> Hilfsroutinen <--}	function anfangswert (var xt: bereich_xt; nt: integer; xe: real): bereich_xt;		{füllt die virtuellen Signalspeicher}		var			i: integer;	begin		for i := 0 to nt do			begin				xt[i] := xe;			end;		anfangswert := xt;	end;	function zyklen (var n: longint; n_text: str255): integer;		{rechnet die Zeitangabe in Schleifendurchlaufzahl um}	begin		if ((pos('d', n_text) > 0) or (pos('T', n_text) > 0)) then			factor := 86400		else if ((pos('h', n_text) > 0) or (pos('St', n_text) > 0)) then			factor := 3600		else if pos('m', n_text) > 0 then			factor := 60		else if pos('s', n_text) > 0 then			factor := 1		else			factor := round(delt);		zyklen := round(n * factor / delt) + 1;	end;	function getgauss (sigma: real): real;		{errechnet Gauß-verteilte Zufallszahlen nach dem Box-Müller-Verfahren}		var			u1, u2: real;	begin		if noiseflag then			begin				randSeed := TickCount;				u1 := ((random + 32768) / 65536);				u2 := ((random + 32768) / 65536);				getgauss := abs(1 + sqrt(-2 * (ln(u1))) * cos(2 * pi * u2) * sigma);			end		else			getgauss := 1;	end;	function arc (chi: real): real;		{rechnet Winkel von Grad nach Bogenmaß um}	begin		arc := 2 * pi * (chi / 360);	end;	function arccosinus (cosphi: real): real;		{errechnet den Arcus-Cosinus einer Zahl zwischen -1 und 1}		var			arcsin: real;	begin		arcsin := arctan(cosphi / sqrt(1 - sqr(cosphi)));		arccosinus := arc(90) - arcsin;	end;	procedure SetzeBasisvariablen;	begin		t := 0;		delt := 100;							{Rechenschrittweite in Sekunden; Richtwert: 1/3*kleinste Halbwertszeit}		signalflag := false;					{Liegt Testsignal an?}		i0 := 0;		dTSH := 0.001;						{mU/s		Gebremste Produktionsrate[errechnet nach D'Angelo 1976, Okuno 1979 und Greenspan 1997]}{Anfangswerte:}		TRHe := 0;							{mol/l		exogen zugeführtes TRH}		TRHi := 2500;						{ng/l		endogenes TRH, nach Rondeel et al. 1988}		TRHi := TRHi * UTRH;				{mol/l}		TRH := TRHi + TRHe;				{mol/l		portale Gesamtkonzentration}		TSH := 2;								{mU/l		aus Referenzwert}		TSHz := 4;							{Mittlerer Wert}		T4 := 7;								{µg/dl		aus Referenzwert}		T4 := T4 * 1000 * UFT4;			{mol/l}		FT4 := 1.3;							{ng/dl		aus Referenzwert}		FT4 := FT4 * UFT4;					{mol/l}		T3p := 130;							{ng/dl		aus Referenzwert}		T3p := T3p * 10 * UFT3;			{mol/l}		FT3 := 3.2;							{pg/ml	aus Referenzwert}		FT3 := FT3 * UFT3;					{mol/l}		T3z := 8200;							{pg/ml}		T3z := T3z * UFT3;					{mol/l}		TBG := 3e-7;							{mol/l		aus Referenzwert}		TBPA := 4.5e-6;						{mol/l		aus Referenzwert}		IBS := 8e-6;							{mol/l		geschätzt aus TBG-Spiegel, korrigiert auf intrazelluläre Akkumulation [Hays et al. 1988]}	end;	procedure SetzeAbgeleiteteVariablen;	begin		T3n := T3z / (1 + k31 * IBS);		T3R := GR * T3n / (DR + T3n);	{Aus physiologischem Anfangswert für T3z errechnet}		gH := dTSH * (DH + TRH) * (1 + LS * T3R) * (1 + Ss * alphaS2 * dTSH / (betaS2 * DS + alphaS2 * dTSH)) / TRH;											{Max. ungebremste Sekretionsleitung der Hypophyse; Näherungswert: 817 mU/s}	end;	procedure Standardwerte;	begin{Parameter und Anfangswerte setzen }		SetzeBasisvariablen;{Referenzwerte:}{TRH: 5 — 6 ng/l im peripheren Blut, ca. 2000 ng/l im Portalsystem}{TSH: 0,4 — 4 mU/l oder 9 — 29 µmol/l}{TT4: 4,5 — 10 µg/dl oder 57,9 — 128,7 nmol/l}{FT4: 0,8 — 1,8 ng/dl oder 10 — 23 pmol/l}{TT3: 80 — 180 ng/dl oder 1,23 — 2,77 nmol/l}{FT3: 2,3 — 4,2 pg/ml oder 3,5 — 6,5 µmol/l}{Übertragungsbeiwerte:}		alphaR := 0.4;						{/l			Verdünnungsfaktor für TRH bei TRH-Test, wie alphaS}		alphaS := 0.4;						{/l			bei V0 = 2.5l (Peptidhormon, das sich nur im peripheren Plasma verteilt)}		betaS := 2.3e-4;						{/s		bei HWZ von ca. 50 Min. [Li et al. 1995, Odell et al. 1967]}		alphaS2 := 2.6e5;					{/l			bei V0 = 3,8µl (errechnet u. a. nach Edelman 1959)}		betaS2 := 140;						{/s		Kinetik primär unbekannt, Analogieschluß aus typ. Rezeptorpotentialen, entspricht HWZ von 5 ms}		dH := 47e-9; 							{mol/l		[Le Dafniet et al. 1994]: 47 nmol/l}		dR := 0.1e-9;							{mol/l		[Vybok et al. 1994, Lazar et al., 1990]}		GR := 1;								{mol/s	auf 1 normiert, da Rückkoppelungsstärke durch LS quantifiziert}		SS := 100;							{l/mU		errechnet aus Werten von [Kakita et al. 1984] mit Lineweaver-Burk-Regression}		DS := 50;								{mU/l		errechnet aus Werten von [Kakita et al. 1984] mit Lineweaver-Burk-Regression}		GT := 1.5e-12 * 2.25;				{mol/s	2.25-facher Wert der mittleren Produktionsrate [Li et al. 1995]}		alphaT := 0.1;						{/l			bei V0 = 10 l [Greenspan 1997]}		betaT := 1.1e-6;						{/s		bei HWZ von 7 Tagen [Greenspan 1997]}		dT := 2.75;							{mU/l		[gemittelt nach Dumont & Vassart 1995]}		GD1 := 2.8e-8;						{mol/sec	aus Referenzwerten ermittelt}		GD2 := 4.3e-15;						{mol/sec	aus hypophysärem T3-Gehalt errechnet}		alpha31 := 2.6e-2;					{/l			bei V0 = 38 l [Greenspan 1997]}		beta31 := 8e-6;						{/s		bei HWZ von 24h [Greenspan 1997]}		alpha32 := 1.3e5;					{/l			aus V0 = 7,6 µl errechnet}		beta32 := 8.3e-4;					{/s		bei HWZ von 15 Minuten [Oppenheimer et al. 1967}		kM1 := 0.5e-6;						{mol/l		[Greenspan 1997]}		kM2 := 1e-9;							{mol/l		[Visser et al. 1983]}		k30 := 2e9;							{l/mol		[Li et al. 1995]}		k31 := 2e9;							{l/mol		geschätzt}		k41 := 2e10;							{l/mol		[Li et al. 1995]}		k42 := 2e8;							{l/mol		[Li et al. 1995]}		k3 := GD2 * alpha32 / (beta32 * (1 + k31 * IBS));	{Zur Errechnung von LS aus klinischen Daten}		G3 := k3 * GR / (k3 + dR);			{dto.: Verstärkungsfaktor für T3z }		AC1 := 500;							{dto.: typische ungebremste TSH-Konzentration}		MI := AC1 / 0.001;					{dto.: Inhibitions-Stärke }		LS := MI / G3;						{Ausgleich von GR; LS hängt dann nur von emp. Daten ab; Näherungswert: 1.68 e6 l/mol}		SetzeAbgeleiteteVariablen;		x1 := TRH;		x2 := TSH;		x3 := T4;		x4 := T3z;		x5 := T3p;		x6 := TSHz;{Zeitkonstanten:}		t121 := 300;							{TRH: Halbwertszeit in Sekunden}		betaR := ln(2) / t121;				{Clearance-Exponent für TRH}		t122 := ln(2) / betaS;				{TSH: Halbwertszeit in Sekunden}		t123 := ln(2) / betaT;				{T4: Halbwertszeit in Sekunden}		t124 := ln(2) / beta32;				{T3z: Halbwertszeit in Sekunden}		t125 := ln(2) / beta31;				{T3p: Halbwertszeit in Sekunden}		t126 := ln(2) / betaS2;				{TSHz: Halbwertszeit in Sekunden}		tpt11 := t121 / ln(2);				{Verzögerungskonstante 1. Ordnung für TRH}		tpt12 := t122 / ln(2);				{Verzögerungskonstante 1. Ordnung für TSH}		tpt13 := t123 / ln(2);				{Verzögerungskonstante 1. Ordnung für T4}		tpt14 := t124 / ln(2);				{Verzögerungskonstante 1. Ordnung für T3z}		tpt15 := t125 / ln(2);				{Verzögerungskonstante 1. Ordnung für T3p}		tpt16 := t126 / ln(2);				{Verzögerungskonstante 1. Ordnung für TSHz}		Tt1 := 1800;							{Totzeit für TRH}		Tt2 := 120;							{Totzeit für TSH}		Tt22 := 3240;						{Totzeit für Ultrashort-Feedback-Wirkung [abgeleitet von Greenspan 1997]}		Tt3 := 300;							{Totzeit für T4}		Tt4 := 3600;							{Totzeit für T3z}		nt2 := trunc(Tt2 / delt); {'trunc' rundet immer ab, 'round' rundet zur nächsten ganzen Zahl}		nt22 := trunc(Tt22 / delt);		nt3 := trunc(Tt3 / delt);		nt4 := trunc(Tt4 / delt);		gSelectedxVariable := vart;		gSelectedyVariable := varTSH;	end;{----------------> Abfrage der Parameter <--}	procedure UpdatetheRadioButtons;		var			ItemType: INTEGER;			itemRect: Rect;			itemHandle: Handle;	begin		GetDItem(gStartDialog, RUN_SECONDS_RADIO, itemType, itemHandle, itemRect);		if tmax_unit = 's' then			SetCtlValue(ControlHandle(itemHandle), ON)		else			SetCtlValue(ControlHandle(itemHandle), OFF);		GetDItem(gStartDialog, RUN_MINUTES_RADIO, itemType, itemHandle, itemRect);		if tmax_unit = 'm' then			SetCtlValue(ControlHandle(itemHandle), ON)		else			SetCtlValue(ControlHandle(itemHandle), OFF);		GetDItem(gStartDialog, RUN_HOURS_RADIO, itemType, itemHandle, itemRect);		if tmax_unit = 'h' then			SetCtlValue(ControlHandle(itemHandle), ON)		else			SetCtlValue(ControlHandle(itemHandle), OFF);		GetDItem(gStartDialog, RUN_DAYS_RADIO, itemType, itemHandle, itemRect);		if tmax_unit = 'd' then			SetCtlValue(ControlHandle(itemHandle), ON)		else			SetCtlValue(ControlHandle(itemHandle), OFF);		GetDItem(gStartDialog, TEST_SECONDS_RADIO, itemType, itemHandle, itemRect);		if i1_unit = 's' then			SetCtlValue(ControlHandle(itemHandle), ON)		else			SetCtlValue(ControlHandle(itemHandle), OFF);		GetDItem(gStartDialog, TEST_MINUTES_RADIO, itemType, itemHandle, itemRect);		if i1_unit = 'm' then			SetCtlValue(ControlHandle(itemHandle), ON)		else			SetCtlValue(ControlHandle(itemHandle), OFF);		GetDItem(gStartDialog, TEST_HOURS_RADIO, itemType, itemHandle, itemRect);		if i1_unit = 'h' then			SetCtlValue(ControlHandle(itemHandle), ON)		else			SetCtlValue(ControlHandle(itemHandle), OFF);		GetDItem(gStartDialog, TEST_DAYS_RADIO, itemType, itemHandle, itemRect);		if i1_unit = 'd' then			SetCtlValue(ControlHandle(itemHandle), ON)		else			SetCtlValue(ControlHandle(itemHandle), OFF);		GetDItem(gStartDialog, TEST_TRH_RADIO, itemType, itemHandle, itemRect);		if testflag then			SetCtlValue(ControlHandle(itemHandle), ON)		else			SetCtlValue(ControlHandle(itemHandle), OFF);		GetDItem(gStartDialog, TEST_TBG_RADIO, itemType, itemHandle, itemRect);		if tbgflag then			SetCtlValue(ControlHandle(itemHandle), ON)		else			SetCtlValue(ControlHandle(itemHandle), OFF);		GetDItem(gStartDialog, TEST_OFF_RADIO, itemType, itemHandle, itemRect);		if (testflag or tbgflag) then			SetCtlValue(ControlHandle(itemHandle), OFF)		else			SetCtlValue(ControlHandle(itemHandle), ON);	end;	procedure HandleTimeConstSettings;		var			dialogDone: BOOLEAN;			itemHit, itemType: INTEGER;			itemRect: Rect;			itemHandle: Handle;			oldPort: GrafPtr;			theString, theItemText: Str255;			theField: timeconst_edit_ids;	begin		if gTimeConstDialog = nil then			gTimeConstDialog := GetNewDialog(RES_BASE + 6, nil, WindowPtr(-1));		SelectWindow(gTimeConstDialog);		ShowWindow(gTimeConstDialog);		GetPort(oldPort);		SetPort(gTimeConstDialog);		GetDItem(gTimeConstDialog, integer(tt0r), itemType, itemHandle, itemRect);		theString := FilteredString(Tt1);		SetIText(itemHandle, theString);		GetDItem(gTimeConstDialog, integer(tt0s), itemType, itemHandle, itemRect);		theString := FilteredString(Tt2);		SetIText(itemHandle, theString);		GetDItem(gTimeConstDialog, integer(tt0s2), itemType, itemHandle, itemRect);		theString := FilteredString(Tt22);		SetIText(itemHandle, theString);		GetDItem(gTimeConstDialog, integer(tt0t), itemType, itemHandle, itemRect);		theString := FilteredString(Tt3);		SetIText(itemHandle, theString);		GetDItem(gTimeConstDialog, integer(tt03z), itemType, itemHandle, itemRect);		theString := FilteredString(Tt4);		SetIText(itemHandle, theString);		GetDItem(gTimeConstDialog, OPTIONS_OK_BUTTON, itemType, itemHandle, itemRect);		HiliteControl(ControlHandle(itemHandle), CONTROL_ACTIVATE);		DoOutlineControl(itemHandle);		dialogDone := FALSE;		while dialogDone = FALSE do			begin				ModalDialog(nil, itemHit);				theField := timeconst_edit_ids(itemHit);				case theField of					timeconstok: 						begin							HideWindow(gTimeConstDialog);							dialogDone := true;							GetDItem(gTimeConstDialog, integer(tt0r), itemType, itemHandle, itemRect);							GetIText(itemHandle, theItemText);							Tt1 := ExtendedForm(theItemText);							GetDItem(gTimeConstDialog, integer(tt0s), itemType, itemHandle, itemRect);							GetIText(itemHandle, theItemText);							Tt2 := ExtendedForm(theItemText);							GetDItem(gTimeConstDialog, integer(tt0s2), itemType, itemHandle, itemRect);							GetIText(itemHandle, theItemText);							Tt22 := ExtendedForm(theItemText);							GetDItem(gTimeConstDialog, integer(tt0t), itemType, itemHandle, itemRect);							GetIText(itemHandle, theItemText);							Tt3 := ExtendedForm(theItemText);							GetDItem(gTimeConstDialog, integer(tt03z), itemType, itemHandle, itemRect);							GetIText(itemHandle, theItemText);							Tt4 := ExtendedForm(theItemText);						end;					timeconstcancel: 						begin							HideWindow(gTimeConstDialog);							dialogDone := true;						end;					otherwise						begin						end;				end;			end;	end;	procedure FillInParameters;		var			itemHit, itemType: INTEGER;			itemRect: Rect;			itemHandle: Handle;			theString: Str255;	begin		GetDItem(gParDialog, integer(alphaRE), itemType, itemHandle, itemRect);		theString := FilteredString(alphaR);		SetIText(itemHandle, theString);		GetDItem(gParDialog, integer(betaRE), itemType, itemHandle, itemRect);		theString := FilteredString(betaR);		SetIText(itemHandle, theString);		GetDItem(gParDialog, integer(alphaSE), itemType, itemHandle, itemRect);		theString := FilteredString(alphaS);		SetIText(itemHandle, theString);		GetDItem(gParDialog, integer(betaSE), itemType, itemHandle, itemRect);		theString := FilteredString(betaS);		SetIText(itemHandle, theString);		GetDItem(gParDialog, integer(alphaS2E), itemType, itemHandle, itemRect);		theString := FilteredString(alphaS2);		SetIText(itemHandle, theString);		GetDItem(gParDialog, integer(betaS2E), itemType, itemHandle, itemRect);		theString := FilteredString(betaS2);		SetIText(itemHandle, theString);		GetDItem(gParDialog, integer(alphaTE), itemType, itemHandle, itemRect);		theString := FilteredString(alphaT);		SetIText(itemHandle, theString);		GetDItem(gParDialog, integer(betaTE), itemType, itemHandle, itemRect);		theString := FilteredString(betaT);		SetIText(itemHandle, theString);		GetDItem(gParDialog, integer(alpha31E), itemType, itemHandle, itemRect);		theString := FilteredString(alpha31);		SetIText(itemHandle, theString);		GetDItem(gParDialog, integer(beta31E), itemType, itemHandle, itemRect);		theString := FilteredString(beta31);		SetIText(itemHandle, theString);		GetDItem(gParDialog, integer(alpha32E), itemType, itemHandle, itemRect);		theString := FilteredString(alpha32);		SetIText(itemHandle, theString);		GetDItem(gParDialog, integer(beta32E), itemType, itemHandle, itemRect);		theString := FilteredString(beta32);		SetIText(itemHandle, theString);		GetDItem(gParDialog, integer(GRE), itemType, itemHandle, itemRect);		theString := FilteredString(GR);		SetIText(itemHandle, theString);		GetDItem(gParDialog, integer(DRE), itemType, itemHandle, itemRect);		theString := FilteredString(dR);		SetIText(itemHandle, theString);		GetDItem(gParDialog, integer(GHE), itemType, itemHandle, itemRect);		theString := FilteredString(GH);		SetIText(itemHandle, theString);		GetDItem(gParDialog, integer(DHE), itemType, itemHandle, itemRect);		theString := FilteredString(dH);		SetIText(itemHandle, theString);		GetDItem(gParDialog, integer(LSE), itemType, itemHandle, itemRect);		theString := FilteredString(LS);		SetIText(itemHandle, theString);		GetDItem(gParDialog, integer(GTE), itemType, itemHandle, itemRect);		theString := FilteredString(GT);		SetIText(itemHandle, theString);		GetDItem(gParDialog, integer(DTE), itemType, itemHandle, itemRect);		theString := FilteredString(dT);		SetIText(itemHandle, theString);		GetDItem(gParDialog, integer(GD1E), itemType, itemHandle, itemRect);		theString := FilteredString(GD1);		SetIText(itemHandle, theString);		GetDItem(gParDialog, integer(KM1E), itemType, itemHandle, itemRect);		theString := FilteredString(kM1);		SetIText(itemHandle, theString);		GetDItem(gParDialog, integer(GD2E), itemType, itemHandle, itemRect);		theString := FilteredString(GD2);		SetIText(itemHandle, theString);		GetDItem(gParDialog, integer(kM2E), itemType, itemHandle, itemRect);		theString := FilteredString(kM2);		SetIText(itemHandle, theString);		GetDItem(gParDialog, integer(SSE), itemType, itemHandle, itemRect);		theString := FilteredString(SS);		SetIText(itemHandle, theString);		GetDItem(gParDialog, integer(DSE), itemType, itemHandle, itemRect);		theString := FilteredString(dS);		SetIText(itemHandle, theString);		GetDItem(gParDialog, integer(K30E), itemType, itemHandle, itemRect);		theString := FilteredString(k30);		SetIText(itemHandle, theString);		GetDItem(gParDialog, integer(K31E), itemType, itemHandle, itemRect);		theString := FilteredString(k31);		SetIText(itemHandle, theString);		GetDItem(gParDialog, integer(K41E), itemType, itemHandle, itemRect);		theString := FilteredString(k41);		SetIText(itemHandle, theString);		GetDItem(gParDialog, integer(K42E), itemType, itemHandle, itemRect);		theString := FilteredString(k42);		SetIText(itemHandle, theString);	end;	procedure HandleParameterSettings;		var			dialogDone: BOOLEAN;			itemHit, itemType: INTEGER;			itemRect: Rect;			itemHandle: Handle;			oldPort: GrafPtr;			theField: par_edit_ids;			theItemText: Str255;	begin		if gParDialog = nil then			gParDialog := GetNewDialog(RES_BASE + 5, nil, WindowPtr(-1));		SelectWindow(gParDialog);		ShowWindow(gParDialog);		GetPort(oldPort);		SetPort(gParDialog);		FillInParameters;		GetDItem(gParDialog, OPTIONS_OK_BUTTON, itemType, itemHandle, itemRect);		HiliteControl(ControlHandle(itemHandle), CONTROL_ACTIVATE);		DoOutlineControl(itemHandle);		dialogDone := FALSE;		while dialogDone = FALSE do			begin				ModalDialog(nil, itemHit);				theField := par_edit_ids(itemHit);				case theField of					paramok: 						begin							HideWindow(gParDialog);							dialogDone := true;							GetDItem(gParDialog, integer(alphaRE), itemType, itemHandle, itemRect);							GetIText(itemHandle, theItemText);							alphaR := ExtendedForm(theItemText);							GetDItem(gParDialog, integer(betaRE), itemType, itemHandle, itemRect);							GetIText(itemHandle, theItemText);							betaR := ExtendedForm(theItemText);							GetDItem(gParDialog, integer(alphaSE), itemType, itemHandle, itemRect);							GetIText(itemHandle, theItemText);							alphaS := ExtendedForm(theItemText);							GetDItem(gParDialog, integer(betaSE), itemType, itemHandle, itemRect);							GetIText(itemHandle, theItemText);							betaS := ExtendedForm(theItemText);							GetDItem(gParDialog, integer(alphaS2E), itemType, itemHandle, itemRect);							GetIText(itemHandle, theItemText);							alphaS2 := ExtendedForm(theItemText);							GetDItem(gParDialog, integer(betaS2E), itemType, itemHandle, itemRect);							GetIText(itemHandle, theItemText);							betaS2 := ExtendedForm(theItemText);							GetDItem(gParDialog, integer(alphaTE), itemType, itemHandle, itemRect);							GetIText(itemHandle, theItemText);							alphaT := ExtendedForm(theItemText);							GetDItem(gParDialog, integer(betaTE), itemType, itemHandle, itemRect);							GetIText(itemHandle, theItemText);							betaT := ExtendedForm(theItemText);							GetDItem(gParDialog, integer(alpha31E), itemType, itemHandle, itemRect);							GetIText(itemHandle, theItemText);							alpha31 := ExtendedForm(theItemText);							GetDItem(gParDialog, integer(beta31E), itemType, itemHandle, itemRect);							GetIText(itemHandle, theItemText);							beta31 := ExtendedForm(theItemText);							GetDItem(gParDialog, integer(alpha32E), itemType, itemHandle, itemRect);							GetIText(itemHandle, theItemText);							alpha32 := ExtendedForm(theItemText);							GetDItem(gParDialog, integer(beta32E), itemType, itemHandle, itemRect);							GetIText(itemHandle, theItemText);							beta32 := ExtendedForm(theItemText);							GetDItem(gParDialog, integer(GRE), itemType, itemHandle, itemRect);							GetIText(itemHandle, theItemText);							GR := ExtendedForm(theItemText);							GetDItem(gParDialog, integer(dRE), itemType, itemHandle, itemRect);							GetIText(itemHandle, theItemText);							dR := ExtendedForm(theItemText);							GetDItem(gParDialog, integer(GHE), itemType, itemHandle, itemRect);							GetIText(itemHandle, theItemText);							GH := ExtendedForm(theItemText);							GetDItem(gParDialog, integer(dHE), itemType, itemHandle, itemRect);							GetIText(itemHandle, theItemText);							dH := ExtendedForm(theItemText);							GetDItem(gParDialog, integer(LSE), itemType, itemHandle, itemRect);							GetIText(itemHandle, theItemText);							LS := ExtendedForm(theItemText);							GetDItem(gParDialog, integer(GTE), itemType, itemHandle, itemRect);							GetIText(itemHandle, theItemText);							GT := ExtendedForm(theItemText);							GetDItem(gParDialog, integer(dTE), itemType, itemHandle, itemRect);							GetIText(itemHandle, theItemText);							dT := ExtendedForm(theItemText);							GetDItem(gParDialog, integer(GD1E), itemType, itemHandle, itemRect);							GetIText(itemHandle, theItemText);							GD1 := ExtendedForm(theItemText);							GetDItem(gParDialog, integer(kM1E), itemType, itemHandle, itemRect);							GetIText(itemHandle, theItemText);							kM1 := ExtendedForm(theItemText);							GetDItem(gParDialog, integer(GD2E), itemType, itemHandle, itemRect);							GetIText(itemHandle, theItemText);							GD2 := ExtendedForm(theItemText);							GetDItem(gParDialog, integer(kM2E), itemType, itemHandle, itemRect);							GetIText(itemHandle, theItemText);							kM2 := ExtendedForm(theItemText);							GetDItem(gParDialog, integer(SSE), itemType, itemHandle, itemRect);							GetIText(itemHandle, theItemText);							SS := ExtendedForm(theItemText);							GetDItem(gParDialog, integer(dSE), itemType, itemHandle, itemRect);							GetIText(itemHandle, theItemText);							dS := ExtendedForm(theItemText);							GetDItem(gParDialog, integer(k30E), itemType, itemHandle, itemRect);							GetIText(itemHandle, theItemText);							k30 := ExtendedForm(theItemText);							GetDItem(gParDialog, integer(k31E), itemType, itemHandle, itemRect);							GetIText(itemHandle, theItemText);							k31 := ExtendedForm(theItemText);							GetDItem(gParDialog, integer(k41E), itemType, itemHandle, itemRect);							GetIText(itemHandle, theItemText);							k41 := ExtendedForm(theItemText);							GetDItem(gParDialog, integer(k42E), itemType, itemHandle, itemRect);							GetIText(itemHandle, theItemText);							k42 := ExtendedForm(theItemText);						end;					paramcancel: 						begin							HideWindow(gParDialog);							dialogDone := true;						end;					otherwise						begin						end;				end;			end;		SetPort(oldPort);	end;	function RunOptionsFilter (theDialog: DialogPtr; var theEvent: EventRecord; var theItem: integer): boolean;	begin		DrawPopUps(theDialog);		RunOptionsFilter := false;	end;	procedure HandleRunOptions;		{zeichnet Dialogbox für Laufzeitoptionen}		var			dialogDone: BOOLEAN;			itemHit, itemType: INTEGER;			itemRect: Rect;			itemHandle: Handle;			oldPort: GrafPtr;			noise, preview: boolean;			thePoint, popUpUpperLeft: Point;			theChoice: longint;	begin		if gOptionsDialog = nil then			gOptionsDialog := GetNewDialog(RES_BASE + 1, nil, WindowPtr(-1));		SelectWindow(gOptionsDialog);		ShowWindow(gOptionsDialog);		GetPort(oldPort);		SetPort(gOptionsDialog);		GetDItem(gOptionsDialog, OPTIONS_OK_BUTTON, itemType, itemHandle, itemRect);		HiliteControl(ControlHandle(itemHandle), CONTROL_ACTIVATE);		DoOutlineControl(itemHandle);		GetDItem(gOptionsDialog, NOISE_CHECKBOX, itemType, itemHandle, itemRect);		noise := noiseflag;		preview := previewflag;		if noise then			SetCtlValue(ControlHandle(itemHandle), ON)		else			SetCtlValue(ControlHandle(itemHandle), OFF);		GetDItem(gOptionsDialog, PREVIEW_CHECKBOX, itemType, itemHandle, itemRect);		if preview then			SetCtlValue(ControlHandle(itemHandle), ON)		else			SetCtlValue(ControlHandle(itemHandle), OFF);		PopUpMenuInit(gOptionsDialog);		dialogDone := FALSE;		while dialogDone = FALSE do			begin				ModalDialog(@RunOptionsFilter, itemHit);				case ItemHit of					OPTIONS_OK_BUTTON: 						begin							HideWindow(gOptionsDialog);							noiseflag := noise;							previewflag := preview;							dialogDone := true;						end;					OPTIONS_CANCEL_BUTTON: 						begin							HideWindow(gOptionsDialog);							dialogDone := true;						end;					NOISE_CHECKBOX: 						begin							GetDItem(gOptionsDialog, NOISE_CHECKBOX, itemType, itemHandle, itemRect);							if noise then								begin									noise := false;									SetCtlValue(ControlHandle(itemHandle), OFF);								end							else								begin									noise := true;									SetCtlValue(ControlHandle(itemHandle), ON)								end;						end;					PREVIEW_CHECKBOX: 						begin							GetDItem(gOptionsDialog, PREVIEW_CHECKBOX, itemType, itemHandle, itemRect);							if preview then								begin									preview := false;									SetCtlValue(ControlHandle(itemHandle), OFF);								end							else								begin									preview := true;									SetCtlValue(ControlHandle(itemHandle), ON)								end;						end;					X_AXIS_MENU: 						begin							TextSize(POPUP_SIZE);							TextFont(applFont);							popUpUpperLeft.v := gxPopUpRect.top + PIXEL_FOR_TOP_LINE;							popUpUpperLeft.h := gxPopUpRect.left;							LocalToGlobal(popUpUpperLeft);							EraseRect(gxPopUpRect);							theChoice := PopUpMenuSelect(gxPopUp, popUpUpperLeft.v, popUpUpperLeft.h, integer(gSelectedxVariable) + 1);							if LoWord(theChoice) > 0 then								begin									gSelectedxVariable := tVariable(LoWord(theChoice) - 1);								end;							DrawPopUpItems(gOptionsDialog);							FrameRect(gxPopUpRect);						end;					Y_AXIS_MENU: 						begin							TextSize(POPUP_SIZE);							TextFont(applFont);							popUpUpperLeft.v := gyPopUpRect.top + PIXEL_FOR_TOP_LINE;							popUpUpperLeft.h := gyPopUpRect.left;							LocalToGlobal(popUpUpperLeft);							EraseRect(gyPopUpRect);							theChoice := PopUpMenuSelect(gyPopUp, popUpUpperLeft.v, popUpUpperLeft.h, integer(gSelectedyVariable) + 1);							if LoWord(theChoice) > 0 then								begin									gSelectedyVariable := tVariable(LoWord(theChoice) - 1);								end;							DrawPopUpItems(gOptionsDialog);							FrameRect(gyPopUpRect);						end;				end;			end;		SetPort(oldPort);	end;	procedure HandleStartDialog;		{zeichnet Dialogbox zur Eingabe der Laufparameter}		var			dialogDone: BOOLEAN;			itemHit, itemType: INTEGER;			itemRect: Rect;			itemHandle: Handle;			oldPort: GrafPtr;	begin		if gStartDialog = nil then			gStartDialog := GetNewDialog(RES_BASE, nil, WindowPtr(-1));		SelectWindow(gStartDialog);		ShowWindow(gStartDialog);		GetPort(oldPort);		SetPort(gStartDialog);		GetDItem(gStartDialog, START_BUTTON, itemType, itemHandle, itemRect);		HiliteControl(ControlHandle(itemHandle), CONTROL_ACTIVATE);		DoOutlineControl(itemHandle);		GetDItem(gStartDialog, RUN_SECONDS_RADIO, itemType, itemHandle, itemRect);		HiliteControl(ControlHandle(itemHandle), CONTROL_DEACTIVATE);		GetDItem(gStartDialog, RUN_MINUTES_RADIO, itemType, itemHandle, itemRect);		HiliteControl(ControlHandle(itemHandle), CONTROL_ACTIVATE);		GetDItem(gStartDialog, RUN_HOURS_RADIO, itemType, itemHandle, itemRect);		HiliteControl(ControlHandle(itemHandle), CONTROL_ACTIVATE);		GetDItem(gStartDialog, RUN_DAYS_RADIO, itemType, itemHandle, itemRect);		HiliteControl(ControlHandle(itemHandle), CONTROL_ACTIVATE);		GetDItem(gStartDialog, TEST_TRH_RADIO, itemType, itemHandle, itemRect);		HiliteControl(ControlHandle(itemHandle), CONTROL_ACTIVATE);		GetDItem(gStartDialog, TEST_OFF_RADIO, itemType, itemHandle, itemRect);		HiliteControl(ControlHandle(itemHandle), CONTROL_ACTIVATE);		GetDItem(gStartDialog, TEST_SECONDS_RADIO, itemType, itemHandle, itemRect);		if (testflag or tbgflag) then			HiliteControl(ControlHandle(itemHandle), CONTROL_ACTIVATE)		else			HiliteControl(ControlHandle(itemHandle), CONTROL_DEACTIVATE);		GetDItem(gStartDialog, TEST_MINUTES_RADIO, itemType, itemHandle, itemRect);		if (testflag or tbgflag) then			HiliteControl(ControlHandle(itemHandle), CONTROL_ACTIVATE)		else			HiliteControl(ControlHandle(itemHandle), CONTROL_DEACTIVATE);		GetDItem(gStartDialog, TEST_HOURS_RADIO, itemType, itemHandle, itemRect);		if (testflag or tbgflag) then			HiliteControl(ControlHandle(itemHandle), CONTROL_ACTIVATE)		else			HiliteControl(ControlHandle(itemHandle), CONTROL_DEACTIVATE);		GetDItem(gStartDialog, TEST_DAYS_RADIO, itemType, itemHandle, itemRect);		if (testflag or tbgflag) then			HiliteControl(ControlHandle(itemHandle), CONTROL_ACTIVATE)		else			HiliteControl(ControlHandle(itemHandle), CONTROL_DEACTIVATE);		GetDItem(gStartDialog, CANCEL_BUTTON, itemType, itemHandle, itemRect);		HiliteControl(ControlHandle(itemHandle), CONTROL_ACTIVATE);		SelIText(gStartDialog, RUN_TIME_TEXT, 0, 32767);		UpdatetheRadioButtons;		dialogDone := FALSE;		while dialogDone = FALSE do			begin				ModalDialog(nil, itemHit);				case itemHit of					START_BUTTON: 						begin							HideWindow(gStartDialog);							graphready := FALSE;							runcommand := TRUE;							dialogDone := TRUE;							GetDItem(gStartDialog, RUN_TIME_TEXT, itemType, itemHandle, itemRect);							GetIText(itemHandle, tmax_text);							if (pos(DEC_POINT, tmax_text) > 0) or (pos(DEC_COMMA, tmax_text) > 0) then								tmax := 0							else								StringToNum(tmax_text, tmax);							GetDItem(gStartDialog, TEST_TIME_TEXT, itemType, itemHandle, itemRect);							GetIText(itemHandle, i1_text);							if (pos(DEC_POINT, i1_text) > 0) or (pos(DEC_COMMA, i1_text) > 0) then								tmax := 0							else								StringToNum(i1_text, tt);							if (tmax > 0) then								begin									i := 1;									nmax := zyklen(tmax, tmax_unit);									i1 := zyklen(tt, i1_unit);								end							else								begin									sysbeep(30);									HandleStartDialog;								end;						end;					CANCEL_BUTTON: 						begin							HideWindow(gStartDialog);							runcommand := FALSE;							antwort := 'nein';							dialogDone := TRUE;						end;					OPTIONS_BUTTON: 						begin							HandleRunOptions;						end;					RUN_SECONDS_RADIO: 						begin							tmax_unit := 's';							UpdatetheRadioButtons;						end;					RUN_MINUTES_RADIO: 						begin							tmax_unit := 'm';							UpdatetheRadioButtons;						end;					RUN_HOURS_RADIO: 						begin							tmax_unit := 'h';							UpdatetheRadioButtons;						end;					RUN_DAYS_RADIO: 						begin							tmax_unit := 'd';							UpdatetheRadioButtons;						end;					TEST_TRH_RADIO: 						begin							testflag := TRUE;							tbgflag := FALSE;							UpdatetheRadioButtons;							GetDItem(gStartDialog, TEST_SECONDS_RADIO, itemType, itemHandle, itemRect);							HiliteControl(ControlHandle(itemHandle), CONTROL_ACTIVATE);							GetDItem(gStartDialog, TEST_MINUTES_RADIO, itemType, itemHandle, itemRect);							HiliteControl(ControlHandle(itemHandle), CONTROL_ACTIVATE);							GetDItem(gStartDialog, TEST_HOURS_RADIO, itemType, itemHandle, itemRect);							HiliteControl(ControlHandle(itemHandle), CONTROL_ACTIVATE);							GetDItem(gStartDialog, TEST_DAYS_RADIO, itemType, itemHandle, itemRect);							HiliteControl(ControlHandle(itemHandle), CONTROL_ACTIVATE);						end;					TEST_TBG_RADIO: 						begin							testflag := FALSE;							tbgflag := TRUE;							UpdatetheRadioButtons;							GetDItem(gStartDialog, TEST_SECONDS_RADIO, itemType, itemHandle, itemRect);							HiliteControl(ControlHandle(itemHandle), CONTROL_ACTIVATE);							GetDItem(gStartDialog, TEST_MINUTES_RADIO, itemType, itemHandle, itemRect);							HiliteControl(ControlHandle(itemHandle), CONTROL_ACTIVATE);							GetDItem(gStartDialog, TEST_HOURS_RADIO, itemType, itemHandle, itemRect);							HiliteControl(ControlHandle(itemHandle), CONTROL_ACTIVATE);							GetDItem(gStartDialog, TEST_DAYS_RADIO, itemType, itemHandle, itemRect);							HiliteControl(ControlHandle(itemHandle), CONTROL_ACTIVATE);						end;					TEST_OFF_RADIO: 						begin							testflag := FALSE;							tbgflag := FALSE;							UpdatetheRadioButtons;							GetDItem(gStartDialog, TEST_SECONDS_RADIO, itemType, itemHandle, itemRect);							HiliteControl(ControlHandle(itemHandle), CONTROL_DEACTIVATE);							GetDItem(gStartDialog, TEST_MINUTES_RADIO, itemType, itemHandle, itemRect);							HiliteControl(ControlHandle(itemHandle), CONTROL_DEACTIVATE);							GetDItem(gStartDialog, TEST_HOURS_RADIO, itemType, itemHandle, itemRect);							HiliteControl(ControlHandle(itemHandle), CONTROL_DEACTIVATE);							GetDItem(gStartDialog, TEST_DAYS_RADIO, itemType, itemHandle, itemRect);							HiliteControl(ControlHandle(itemHandle), CONTROL_DEACTIVATE);						end;					TEST_SECONDS_RADIO: 						begin							i1_unit := 's';							UpdatetheRadioButtons						end;					TEST_MINUTES_RADIO: 						begin							i1_unit := 'm';							UpdatetheRadioButtons						end;					TEST_HOURS_RADIO: 						begin							i1_unit := 'h';							UpdatetheRadioButtons						end;					TEST_DAYS_RADIO: 						begin							i1_unit := 'd';							UpdatetheRadioButtons						end;					otherwise						;				end;			end;		SetPort(oldPort);	end;{-----------------> Simulator <--}	procedure Simulator;		var			theContents: tResultContent;	begin    {Hauptteil der Simulationsrechnungen, Aufruf der Unterprogramme, wird regelmäßig bei nullEvent aufgerufen}		simready := false;		if i <= nmax then			begin				graphready := false;				if i mod (rastergap_text) = 0 then					begin						theContents[1] := StringOf(i);						theContents[2] := StringOf(stunden(t));						theContents[3] := StringOf((TRH / UTRH) : 10 : 1);						theContents[4] := StringOf(TSH : 10 : 2);						theContents[5] := StringOf(TSHz : 10 : 2);						theContents[6] := StringOf((FT4 / UFT4) : 10 : 2);						theContents[7] := StringOf((T3z / UFT3));						theContents[8] := StringOf((FT3 / UFT3) : 10 : 2);						writeTableCells(gWerteListe, theContents);						LScroll(0, 1, gWerteListe);					end;				if i mod (rastergap_werte) = 0 then					begin						case gSelectedxVariable of							vart: 								Werte[1, i2] := t;							varTSH: 								Werte[1, i2] := TSH;							varFT4: 								Werte[1, i2] := FT4;							varFT3: 								Werte[1, i2] := FT3;						end;						case gSelectedyVariable of							vart: 								Werte[2, i2] := t;							varTSH: 								Werte[2, i2] := TSH;							varFT4: 								Werte[2, i2] := FT4;							varFT3: 								Werte[2, i2] := FT3;						end;						i2 := i2 + 1;					end;				t := t + delt;{Hypothalamus:}				f := 1 / 86400; {Frequenz des circadianen TRH-Rhythmus}				omega := 2 * pi * f; {Kreisfrequenz}				chi := 2 * pi / 24 * 5;				TRHi := TRH1 + 1500 * cos(omega * t - chi) * UTRH;				TRH := TRHi + TRHe;				TRH := TRH * getgauss(0.5); {Rauscheinfluß}{Hypophyse:}				T3n := T3z / (1 + k31 * IBS);				T3R := GR * T3n / (dR + T3n);				dTSH := gH * TRH / ((dH + TRH) * (1 + LS * T3R) * (1 + SS * TSHz / (DS + TSHz))); {nur Ausschüttungsrate, kein Abbau}				{Näherungswert im Äquifinium: TSHz := (alphaS2 / betaS2) * dTSH;}				vpt10 := alphaS2 / betaS2;				pt1(vpt10, tpt16, x6, dTSH, TSHz);				TSHz := Totzt(xt22, nt22, TSHz);        {TSHz := TSHz * getgauss(0.2); {Rauscheinfluß}				vpt10 := alphaS / betaS;				pt1(vpt10, tpt12, x2, dTSH, TSH);				{Näherungswert im Äquifinium: TSH := alphaS * dTSH / betaS;}				TSH := Totzt(xt2, nt2, TSH);{Schilddrüse:}				dT4 := GT * TSH / (dT + TSH);				vpt10 := alphaT / betaT;				pt1(vpt10, tpt13, x3, dT4, T4);				{Näherungswert im Äquifinium: T4 := alphaT * dT4 / betaT;}				T4 := Totzt(xt3, nt3, T4);				FT4 := T4 / (1 + k41 * TBG + k42 * TBPA);{5'-Dejodinase II (zentral):}				dT3z := GD2 * FT4 / (kM2 + FT4);				vpt10 := alpha32 / beta32;				pt1(vpt10, tpt14, x4, dT3z, T3z);				{Näherungswert im Äquifinium: T3z := alpha32 * dT3z / beta32;}				T3z := Totzt(xt4, nt4, T3z);{5'-Dejodinase I (peripher):}				dT3p := GD1 * FT4 / (kM1 + FT4);				vpt10 := alpha31 / beta31;				pt1(vpt10, tpt15, x5, dT3p, T3p);				{Näherungswert im Äquifinium: T3p := alpha31 * dT3p / beta31;}				FT3 := T3p / (1 + k30 * TBG);				i := i + 1;{Testsignal:}				if (i > i1) and testflag then					begin						signalflag := true;						TRHe := UTRH * (200000 * alphaR * exp(-betaR * (t - i1 * delt)));					end				else if (i > i1) and tbgflag then					begin						signalflag := true;						TBG := 4.5e-7;		 {TBPA := 4.5e-6;}					end;			end		else			begin				Graph;				graphready := true;				simready := true;			end;	end;	procedure Simulationsrahmen;    {erzeugt Fenster, setzt Anfangsbedingungen und berechnet Fixpunkte}		var			destAndViewRect, dataBounds, screenBounds: Rect;			oldPort: GrafPtr;			cSize, theCorner: Point;			n: longint;			linelength, hor, vert: integer;			origFont, origSize: integer;	begin		screenBounds := GetGrayRgn^^.rgnBBox;		GetPort(oldPort);		if gWerteFenster = nil then					{erzeugt Fenster, wenn noch nicht vorhanden}			gWerteFenster := GetNewWindow(RES_BASE + 2, nil, WindowPtr(-1));		ShowWindow(gWerteFenster);					{Wertefenster anzeigen}		if gGraphikFenster = nil then					{erzeugt Fenster, wenn noch nicht vorhanden}			gGraphikFenster := GetNewWindow(RES_BASE + 1, nil, WindowPtr(-1));		if screenBits.bounds.bottom > 400 then			begin				SetPort(gGraphikFenster);				theCorner.h := gGraphikFenster^.portRect.left;				theCorner.v := gGraphikFenster^.portRect.bottom;				LocalToGlobal(theCorner);				hor := theCorner.h;				SetPort(gWerteFenster);				theCorner.h := gWerteFenster^.portRect.left;				theCorner.v := gWerteFenster^.portRect.bottom;				LocalToGlobal(theCorner);				vert := theCorner.v;				MoveWindow(gGraphikFenster, hor, vert + TOP, false);			end;		ShowWindow(gGraphikFenster);				{Graphikfenster anzeigen}		if gVorhersageFenster = nil then			{erzeugt Fenster, wenn noch nicht vorhanden}			gVorhersageFenster := GetNewWindow(RES_BASE + 3, nil, WindowPtr(-1));		if screenBits.bounds.bottom > 500 then			begin				SetPort(gVorhersageFenster);				theCorner.h := gVorhersageFenster^.portRect.left;				theCorner.v := gVorhersageFenster^.portRect.bottom;				LocalToGlobal(theCorner);				hor := theCorner.h;				SetPort(gGraphikFenster);				theCorner.h := gGraphikFenster^.portRect.left;				theCorner.v := gGraphikFenster^.portRect.bottom;				LocalToGlobal(theCorner);				vert := theCorner.v;				MoveWindow(gVorhersageFenster, hor, vert + TOP, false);			end;		ShowWindow(gVorhersageFenster);			{Vorhersagesfenster anzeigen}		SetPort(gWerteFenster);		destAndViewRect := gWerteFenster^.portRect;		with destAndViewRect do			begin				bottom := bottom - SCROLL_BAR_PIXELS + 1;				right := right - SCROLL_BAR_PIXELS + 1;				left := 0;				top := top + CAPTION_HEIGHT;				SetPt(cSize, COL_WIDTH, 12);			end;		SetRect(dataBounds, 0, 0, 8, 0);		origFont := gWerteFenster^.txFont;		origSize := gWerteFenster^.txSize;		TextFont(applFont);		TextSize(9);		gWerteListe := LNew(destAndViewRect, dataBounds, cSize, 400, gWerteFenster, true, false, false, true);		HLock(Handle(gWerteListe));		gVorhersagetext := CreateEditRecord(gVorhersageFenster);		SetzeBasisvariablen;		SetzeAbgeleiteteVariablen;		xt2 := anfangswert(xt2, nt2 + 1, TSH); {bereitet die Totzeitglieder vor}{xt2[nt2] := 0;}		xt22 := anfangswert(xt22, nt22 + 1, TSHz);		xt3 := anfangswert(xt3, nt3 + 1, T4);{xt3[nt3] := 0;}		xt4 := anfangswert(xt4, nt4 + 1, T3z);{xt4[nt4] := 0;}		HandleStartDialog;		if runcommand then			begin				SetCursor(GetCursor(watchCursor)^^);				case gSelectedxVariable of					vart: 						gr_x_schrift := 't';					varTSH: 						gr_x_schrift := 'TSH';					varFT4: 						gr_x_schrift := 'FT4';					varFT3: 						gr_x_schrift := 'FT3';				end;				case gSelectedyVariable of					vart: 						gr_y_schrift := 't';					varTSH: 						gr_y_schrift := 'TSH';					varFT4: 						gr_y_schrift := 'FT4';					varFT3: 						gr_y_schrift := 'FT3';				end;				SetPort(gWerteFenster);				EraseRect(gWerteFenster^.portRect);				DrawCaption;				SetPort(gGraphikFenster);				EraseRect(gGraphikFenster^.portRect);				i2 := 1;{Vorhersagewerte:}				TRH1 := TRH;				k1 := gH * alphaS / betaS;				k11 := alphaS / betaS;				k2 := GT * alphaT / betaT;				k21 := k2;				k22 := k21 / (1 + k41 * TBG + k42 * TBPA);			{k3 := GD2 * alpha32 / beta32;}				k5 := GD1 * alpha31 / beta31;				k51 := k5 / (1 + k30 * TBG);				k6 := 1 / (2 * (1 + SS) * alphaS2);				k61 := k6 * k11;				k7 := dH + TRH1;				k8 := alphaS2 * gH * TRH1 / (dH + TRH1);				k9 := DS * betaS2;			{G3 := k3 * GR / (k3 + dR);}				D3 := kM2 * dR / (k3 + dR);				a1 := (D3 + k22 + LS * G3 * k22) / k61;				b1 := D3 * dT / k61 + 2 * D3 * k9 + 2 * k9 * k22 + 2 * LS * G3 * k9 * k22 - 2 * D3 * k8 - 2 * k8 * k22;				c1 := 2 * (D3 * dT * k9 - D3 * dT * k8 - 2 * (1 + SS) * D3 * k8 * k9 * k61 - 2 * (1 + SS) * k8 * k9 * k22 * k61);				d1 := -4 * (1 + SS) * D3 * dT * k8 * k9 * k61;				r1 := c1 / a1 - 1 / 3 * sqr(b1 / a1);				s1 := 2 / 27 * sqr(b1 / a1) * (b1 / a1) - 1 / 3 * c1 * b1 / sqr(a1) + d1 / a1;				p1 := r1 / 3;				q1 := s1 / 2;				Det := p1 * p1 * p1 + q1 * q1;				if Det > 0 then					begin {Cardano-Formel, eine reale Lösung}						u := exp(ln(-q1 + sqrt(Det)) * (1 / 3));						v := exp(ln(-q1 - sqrt(Det)) * (1 / 3));						y1 := u + v;	{reale Lösung nach der Cardano-Fomel}						y2 := -(u + v) / 2; {Realteil der 1. komplexen Lösung}						y3 := y2; {Realteil der 2. komplexen Lösung, identisch mit y2}					end				else					begin {Casus irreducibilis, drei reale Lösungen}						u := -q1 / (sqrt(-p1 * sqr(-p1))); {cos phi}						phi := arccosinus(u); {Winkel im Bogenmaß}						y1 := 2 * sqrt(-p1) * cos(phi / 3);						y2 := -2 * sqrt(-p1) * cos(phi / 3 + arc(60));						y3 := -2 * sqrt(-p1) * cos(phi / 3 - arc(60));					end;				TSH1 := y1 - b1 / (3 * a1);				TSH2 := y2 - b1 / (3 * a1);				TSH3 := y3 - b1 / (3 * a1);				FT41 := alphaT * GT * TSH1 / (betaT * (dT + TSH1) * (1 + k41 * TBG + k42 * TBPA));				FT42 := alphaT * GT * TSH2 / (betaT * (dT + TSH2) * (1 + k41 * TBG + k42 * TBPA));				FT43 := alphaT * GT * TSH3 / (betaT * (dT + TSH3) * (1 + k41 * TBG + k42 * TBPA));				T3z1 := alpha32 * GD2 * FT41 / (beta32 * (kM2 + FT41));				T3z2 := alpha32 * GD2 * FT42 / (beta32 * (kM2 + FT42));				T3z3 := alpha32 * GD2 * FT43 / (beta32 * (kM2 + FT43));				T3n1 := T3z1 / (1 + k31 * IBS);				T3n2 := T3z2 / (1 + k31 * IBS);				T3n3 := T3z3 / (1 + k31 * IBS);				T3R1 := GR * T3n1 / (DR + T3n1);				T3R2 := GR * T3n2 / (DR + T3n2);				T3R3 := GR * T3n3 / (DR + T3n3);				FT31 := k51 * FT41 / (kM1 + FT41);				FT32 := k51 * FT42 / (kM1 + FT42);				FT33 := k51 * FT43 / (kM1 + FT43);				if previewflag then					begin						TSH := TSH1;						FT4 := FT41;						FT3 := FT31;						T3z := T3z1;						T3R := T3R1;					end;				WriteALine('');				WriteALine(StringOf('Vorausgesagte Gleichgewichtswerte für TSH: ', TSH1 : 13 : 4, ', ', TSH2 : 13 : 4, '     und', TSH3 : 13 : 4));				WriteALine(StringOf('Vorausgesagte Gleichgewichtswerte für FT4: ', (FT41 / UFT4) : 13 : 4, ', ', (FT42 / UFT4) : 13 : 4, '     und', (FT43 / UFT4) : 13 : 4));				WriteALine(StringOf('Vorausgesagte Gleichgewichtswerte für T3z: ', (T3z1 / UFT3) : 13 : 4, ', ', (T3z2 / UFT3) : 13 : 4, '     und', (T3z3 / UFT3) : 13 : 4));				WriteALine(StringOf('Vorausgesagte Gleichgewichtswerte für T3R: ', (T3R1), ', ', (T3R2), '     und', (T3R3)));				WriteAString(StringOf('Vorausgesagte Gleichgewichtswerte für FT3: ', (FT31 / UFT3) : 13 : 4, ', ', (FT32 / UFT3) : 13 : 4, '     und', (FT33 / UFT3) : 13 : 4));{Berechnung der Rasterweite für Ausgabe und Wertespeicherung}				linelength := length(StringOf(i, ' ' : 6, t : 6 : 1, (TRH / UTRH) : 13 : 1, TSH : 13 : 4, TSHz : 13 : 4, (FT4 / UFT4) : 13 : 2, (T3z / UFT3) : 18 : 4, (FT3 / UFT3) : 13 : 2)) + 1;				rastergap_text := nmax * linelength div 32000 + 1;				rastergap_werte := nmax div 2000 + 1;				Simulator;			end;		TextFont(origFont);		TextSize(origSize);		SetPort(oldPort);		SetCursor(arrow);	end;{----------------> Benutzeroberfläche <--}	procedure HandleFileChoice (theItem: INTEGER);		var			theErr: OSErr;			fileMenu: MenuHandle;			whichWindow: WindowPtr;	begin		case theItem of			CLOSE_ITEM: 				begin					whichWindow := FrontWindow;					if whichWindow <> nil then						HideWindow(whichWindow);				end;			SAVE_ITEM: 				begin					theErr := DoSaveSeriesCmd;					if theErr <> noErr then						SysBeep(30);				end;			QUIT_ITEM: 				gDone := TRUE;		end;	end;	procedure HandleAppleChoice (theItem: INTEGER);		var			accName: Str255;			accNumber, itemNumber, dummy: INTEGER;			appleMenu: MenuHandle;	begin		case theItem of			ABOUT_ITEM: 				HandleAbout;			otherwise				begin					appleMenu := GetMHandle(APPLE_MENU_ID);					GetItem(appleMenu, theItem, accName);					accNumber := OpenDeskAcc(accName);				end;		end;	end;	procedure HandleEditChoice (theItem: INTEGER);		var			dummy: Boolean;	begin		case theItem of			COPY_ITEM: 				CopyPict(gLaufbild);			CLIPBOARD_ITEM: 				ShowClip;			otherwise				dummy := SystemEdit(theItem - 1);		end;	end;	procedure HandleSimChoice (theItem: INTEGER);	begin		case theItem of			START_ITEM: 				if simready then					Simulationsrahmen				else					SysBeep(30);			STOP_ITEM: 				i := nmax + 1;			ABOUT_MODEL_ITEM: 				ShowModelInfo;			PARAM_ITEM: 				HandleParameterSettings;			TIME_CONST_ITEM: 				HandleTimeConstSettings;			IPS_ITEM: 				ShowIPS;			otherwise				SysBeep(30);		end;	end;	procedure HandleMenuChoice (menuChoice: LONGINT);		var			theMenu, theItem: INTEGER;	begin		if menuChoice <> 0 then			begin				theMenu := HiWord(MenuChoice);				theItem := LoWord(MenuChoice);				case theMenu of					APPLE_MENU_ID: 						HandleAppleChoice(theItem);					FILE_MENU_ID: 						HandleFileChoice(theItem);					EDIT_MENU_ID: 						HandleEditChoice(theItem);					SIMULATION_MENU_ID: 						HandleSimChoice(theItem);				end;				HiliteMenu(0);			end;	end;	procedure HandleMouseDown;		var			whichWindow: WindowPtr;			mouseXY: Point;			controlHdl: ControlHandle;			oldPort: GrafPtr;			sizeRect: Rect;			partCode, controlValue: integer;			thePart, werte_width: integer;			menuChoice, windSize: longint;			double_clicked: boolean;	begin		mouseXY := gtheEvent.where;		thePart := FindWindow(mouseXY, whichWindow);		werte_width := gWerteFenster^.portRect.right - gWerteFenster^.portRect.left;		SetRect(sizeRect, werte_width, 100, screenBits.Bounds.bottom - screenBits.Bounds.top, werte_width);		case thePart of			inMenuBar: 				begin					AdjustMenus;					menuChoice := MenuSelect(mouseXY);					HandleMenuChoice(menuChoice);				end;			inSysWindow: 				SystemClick(gTheEvent, whichWindow);			inDrag: 				DragWindow(whichWindow, mouseXY, GetGrayRgn^^.rgnBBox);			inGoAway: 				if TrackGoAway(whichWindow, mouseXY) then					HideWindow(whichWindow);			inContent: 				begin					if whichWindow <> FrontWindow then						SelectWindow(whichWindow);					GetPort(oldPort);					SetPort(whichWindow);					GlobalToLocal(mouseXY);					partCode := FindControl(mouseXY, whichWindow, controlHdl);					if whichWindow = gWerteFenster then{if mouseXY.v > gWerteFenster^.portRect.top + 15 then}						double_clicked := LClick(mouseXY, gTheEvent.modifiers, gWerteListe);					SetPort(oldPort);				end;			inGrow: 				begin					windSize := GrowWindow(whichWindow, gTheEvent.where, sizeRect);					GetPort(oldPort);					SetPort(whichWindow);					EraseRect(whichWindow^.portRect);					SizeWindow(whichWindow, LoWord(windSize), HiWord(windSize), true);					InvalRect(whichWindow^.portRect);					SetPort(oldPort);				end;			otherwise				SysBeep(30);		end;	end;	procedure UpdateTheWindow (theWindow: WindowPtr);		var			viewRect: Rect;			oldPort: GrafPtr;	begin		viewRect := theWindow^.portRect;		GetPort(oldPort);		SetPort(theWindow);		if theWindow = gGraphikFenster then			begin				TEDeactivate(gVorhersageText);				EraseRect(viewRect);				if graphready then					Graph;			end		else if theWindow = gClipWindow then			begin				TEDeactivate(gVorhersageText);				EraseRect(viewRect);				ShowClip;			end		else if theWindow = gWerteFenster then			begin				viewRect.right := gWerteFenster^.portRect.right - SCROLL_BAR_PIXELS - 4;				EraseRect(viewRect);				DrawCaption;				TEDeactivate(gVorhersageText);				LActivate(true, gWerteListe);				LUpdate(gWerteFenster^.visRgn, gWerteListe);			end		else if theWindow = gVorhersageFenster then			begin				viewRect.right := gVorhersageFenster^.portRect.right - SCROLL_BAR_PIXELS - 4;				EraseRect(viewRect);				TEUpdate(viewRect, gVorhersageText);				TEActivate(gVorhersageText);				UpdtControl(gVorhersageFenster, gVorhersageFenster^.visRgn);			end;		SetPort(oldPort);	end;	procedure HandleEvent;		var			theChar: CHAR;			dummy, result: BOOLEAN;			oldPort: GrafPtr;			theDialog: DialogPtr;			theDialogItem: INTEGER;			theErr: OSErr;	begin		if gWNEImplemented then			dummy := WaitNextEvent(everyEvent, gTheEvent, SLEEP, nil)		else			begin				SystemTask;				dummy := GetNextEvent(everyEvent, gTheEvent);			end;		case gTheEvent.what of			kHighLevelEvent: 				begin					theErr := AEProcessAppleEvent(gTheEvent);				end;			mouseDown: 				HandleMouseDown;			keyDown, autoKey: 				begin					theChar := CHR(BitAnd(gTheEvent.message, charCodeMask));					if (BitAnd(gTheEvent.modifiers, cmdKey) <> 0) then						begin							AdjustMenus;							HandleMenuChoice(MenuKey(theChar));						end;				end;			diskEvt: 				DoDiskEvent;			updateEvt: 				if not IsDAWindow(WindowPtr(gTheEvent.message)) then					begin						GetPort(oldPort);						SetPort(WindowPtr(gTheEvent.message));						BeginUpdate(WindowPtr(gTheEvent.message));						if WindowPtr(gTheEvent.message) = WindowPtr(gIPSDialog) then							UpdateDialog(WindowPtr(gTheEvent.message), WindowPtr(gTheEvent.message)^.visRgn)						else							UpdateTheWindow(WindowPtr(gTheEvent.message));						EndUpdate(WindowPtr(gTheEvent.message));						SetPort(oldPort);					end;			activateEvt: 				if WindowPtr(gTheEvent.message) = WindowPtr(gIPSDialog) then					result := DialogSelect(gTheEvent, gIPSDialog, theDialogItem)				else					DoActivate(WindowPtr(gTheEvent.message), gTheEvent.modifiers);			nullEvent: 				begin					if not simready then						Simulator;					if FrontWindow = gIPSDialog then						result := DialogSelect(gTheEvent, gIPSDialog, theDialogItem);				end;			otherwise {fängt Events ab, die nicht explizit behandelt werden}				begin				end;		end;	end;{----------------> MainLoop <--}	procedure MainLoop;	begin		gDone := FALSE;		gWNEImplemented := (NGetTrapAddress(WNE_TRAP_NUM, ToolTrap) <> NGetTrapAddress(UNIMPL_TRAP_NUM, ToolTrap));		while (gDone = FALSE) do			HandleEvent;	end;{----------------> Vorbereitung <--}	procedure MenuBarInit;		var			myMenuBar: Handle;			aMenu: MenuHandle;	begin		myMenuBar := GetNewMBar(RES_BASE);		SetMenuBar(myMenuBar);		DisposHandle(myMenuBar);		aMenu := GetMHandle(APPLE_MENU_ID);		if aMenu <> nil then			AddResMenu(aMenu, 'DRVR');		DrawMenuBar;	end;	procedure InitEvents;		var			theErr: OSErr;			response: longint;	begin		gDoOpenAppEventUPP := EventHandlerProcPtr(@HandleOpenApplicationEvent);		gDoQuitAppEventUPP := EventHandlerProcPtr(@DoQuitEvent);		if (Gestalt(gestaltSystemVersion, response) = noErr) and (response >= $0700) then			begin				theErr := AEInstallEventHandler(kCoreEventClass, kAEQuitApplication, gDoQuitAppEventUPP, 0, false);				if theErr = noErr then					theErr := AEInstallEventHandler(kCoreEventClass, kAEOpenApplication, gDoOpenAppEventUPP, 0, false);				if theErr <> noErr then					SysBeep(30);				FlushEvents(everyEvent, 0);			end;	end;	procedure DialogInit;		var			itemType: INTEGER;			itemRect: Rect;			itemHandle: Handle;	begin		gStartDialog := GetNewDialog(RES_BASE, nil, WindowPtr(-1));	end;{----------------> SimThyr <--}begin	graphready := false;	simready := true;	MenuBarInit;	DialogInit;	InitEvents;	InitCursor;	SetCursor(GetCursor(watchCursor)^^);	GetOSVersion;	AdjustMenus;	tmax_unit := 'd';	i1_unit := 'd';	testflag := false;	tbgflag := false;	previewflag := true;	{Sollen die Vorhersagewerte als Ausgangswerte übernommen werden?}	noiseflag := true;		{Soll Gauß-verteiltes Rauschen überlagert werden?}	nmax := 0;	i := 1;	SetCursor(arrow);	Standardwerte;	Simulationsrahmen;	MainLoop;end.{Literatur:																				}{1. Neuber, H., "Simulation von Regelkreisen auf Personal Computern			}{		in Pascal und Fortran 77", IWT, Vaterstetten 1989						}{2. Mark, D., C. Reed, "Macintosh Pascal Programming Primer"				}{		Addison-Wesley, Reading, Ma., Mento Park, Ca., New York 3° 1993	}{3. Borenstein, Ph., J. Mattson, "THINK Pascal™ User Manual"					}{		Symantec Corporation, Cupertino, Ca. 1990 								}{4. Dahl, G. E., N. P. Evans, L. A. Thrun, f. J. Karsch (1994) "A Central 		}{		Negative	Feedback Action of Thyroid Hormones on Thyrotropin-		}{		Releasing Hormone Secretion", Endocrinology 195: 2392-7				}{5. Samuels, M. H., P. Henry, M. Luther, E. C. Ridgway (1993) "Pulsatile		}{		TSH Secretion during 48-Hour Continuous TRH Infusions", Thyroid		}{		3: 201-6																			}{6. Li, G., B. Liu, Y. Liu (1995) "A dynamical model of the pulsatile			}{		secretion of the hypothalamo-pituitary-thyroid axis", BioSystems	}{		35: 83-92																		}{7. Greenspan, F. S. "The Thyroid Gland" in: Greenspan, F. S.,					}{		Strewler, G. J., "Basic and Clinical Endocrinology",						}{		Appleton & Lange, Stamford, CT, 1997										}{8. Visser, T. J., Kaplan, M. M., Leonard, J. L., Larsen, P. R. (1983)			}{		"Evidence for Two Pathways of Iodothyronine 5'-Deiodination in Rat	}{		Pituitary That Differ in Kinetics, Propylthiouracil Sensitivity and		}{		Respone to Hypothyroidism", J. Clin. Invest. 71: 992-1002				}{9. Lee TW; Anderson LA; Eidne KA; Milligan G (1995) 							}{		"Comparison of the signalling properties of the long and short 			}{		isoforms of the rat thyrotropin - releasing - hormone receptor			}{ 		following expression in rat 1 fibroblasts", Biochem J 310: 291-8		}{10. Karhapaa L; Tornquist K (1995) "Caffeine inhibits the binding of			}{		thyrotropin-releasing hormone in GH4C1 pituitary cells."				}{		Biochem Biophys Res Commun 210(3):726-32								}{11. Dumont, J. E., Vassart, G. "Thyroid Regulation" in De. Groot				}{		"Endocrinology", WB Saunders 1995											}{12. Jackson. I. M. D., "Thyrotropin Releasing Factor" in Adelman, G.			}{		"Encyclopedia of Neuroscience", Volume II, Birkhäuser, Boston,		}{		Basel, Stuttgart, 1987															}{13. Okuno, A., Taguchi, T., Takimoto, M. (1979) "Kinetic Analysis of 		}{		Plasma TSH Dynamics after TRH Stimulation" Horm. Metab. Res. 11:	}{		293-5																				}{14. D'Angelo, S. A., Paul, D. H., Wall, N. R., Lombardi, D. M. (1976)			}{		"Pituitary Thyrotropin (TSH) Rebound Phenomenon and Kinetics of		}{		Secretion in the Goitrous Rat: Differential Effects of Thyroxine on		}{		Synthesis and Release of TSH" Endocrinology 99: 935-43				}{15. Rondeel, J. M. M., de Greef, W. J., van der Schoot, P., Karels, B.,		}{		Klootwijk, W., Visser, T. J. (1988) "Effect of Thyroid Status and		}{		Paraventricular Area Lesions on the Release of Thyrotropin-			}{		Releasing Hormone and Catecholamines into Hypophysial Portal			}{		Blood" Endocrinology 123:523-7												}{16. Oppenheimer, J. H., G. Bernstein, J. Hasen (1967) "Estimation of		}{		Rapidly Exchangeable Cellular Thyroxine from the Plasma				}{		Disappearance Curves of Simultaneously Administered Thyroxine-		}{		131I and Albumin-125I" J. Clin. Invest 46: 762-77						}{17. Edelman, I. S., J. Leibman (1959) "Anatomy of Body Water and			}{		Electrolytes", Am. J. Med. 27, 256-77										}{18. Kakita, T., Laborde, N. P., Odell, W. D. (1984) "Autoregulatory			}{		Control of Thyrotrophin in Rabbits", Endocrinology 114: 2301-5		}